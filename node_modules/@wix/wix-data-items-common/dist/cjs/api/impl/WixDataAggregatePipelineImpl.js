"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.WixDataAggregatePipelineImpl = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _WixDataResultImpl = require("./WixDataResultImpl");
var _PipelineValidator = require("../PipelineValidator");
class WixDataAggregatePipelineImpl {
  constructor(collectionName, pipeline, client, limitNumber, skipNumber, invalidArguments) {
    this.collectionName = collectionName;
    this.pipeline = pipeline;
    this.client = client;
    this.limitNumber = limitNumber;
    this.skipNumber = skipNumber;
    (0, _defineProperty2.default)(this, "ownInvalidArguments", void 0);
    this.ownInvalidArguments = invalidArguments ?? [];
  }
  get invalidArguments() {
    return this.ownInvalidArguments;
  }
  async run(options) {
    var _response$pagingMetad, _response$results;
    if (this.invalidArguments.length > 0) {
      throw new Error(this.invalidArguments.join(', '));
    }
    const stages = this.pipeline.map(stage => stage.toProto());
    const response = await this.client.aggregatePipelineDataItems({
      dataCollectionId: this.collectionName,
      stages,
      ...options,
      paging: {
        offset: this.skipNumber,
        limit: this.limitNumber
      }
    });
    const fetch = async (cursorOrOffset, returnTotalCount) => {
      const request = {
        dataCollectionId: this.collectionName,
        stages,
        ...options
      };
      if (typeof cursorOrOffset === 'string') {
        request.cursorPaging = {
          limit: this.limitNumber,
          cursor: cursorOrOffset
        };
        // Stages must not be sent if using cursor paging, as they'll be reused from original request
        request.stages = undefined;
      } else {
        request.paging = {
          limit: this.limitNumber,
          offset: cursorOrOffset
        };
      }
      if (returnTotalCount) {
        request.returnTotalCount = true;
      }
      const {
        results,
        pagingMetadata
      } = await this.client.aggregatePipelineDataItems(request);
      return [results, pagingMetadata];
    };
    return new _WixDataResultImpl.WixDataResultImpl(response.results || [], response.pagingMetadata || {
      count: 0,
      offset: 0
    }, fetch, {
      collectionName: this.collectionName,
      skipNumber: ((_response$pagingMetad = response.pagingMetadata) == null ? void 0 : _response$pagingMetad.offset) || 0,
      limitNumber: (_response$results = response.results) == null ? void 0 : _response$results.length
    });
  }
  limit(limitNumber) {
    const [invalidArguments] = this.pipelineValidator('.limit').arityIsOne(arguments).isPositiveNumber(limitNumber).validateAndAggregate();
    return this.copy({
      limitNumber,
      invalidArguments
    });
  }
  skip(skipNumber) {
    const [invalidArguments] = this.pipelineValidator('.skip').arityIsOne(arguments).isNonNegativeNumber(skipNumber).validateAndAggregate();
    return this.copy({
      skipNumber,
      invalidArguments
    });
  }
  pipelineValidator(operatorName) {
    return new _PipelineValidator.PipelineValidator(operatorName, this.ownInvalidArguments);
  }
  copy(params) {
    return new WixDataAggregatePipelineImpl(this.collectionName, this.pipeline, this.client, params.limitNumber ?? this.limitNumber, params.skipNumber ?? this.skipNumber, params.invalidArguments ?? this.ownInvalidArguments);
  }
}
exports.WixDataAggregatePipelineImpl = WixDataAggregatePipelineImpl;
//# sourceMappingURL=WixDataAggregatePipelineImpl.js.map