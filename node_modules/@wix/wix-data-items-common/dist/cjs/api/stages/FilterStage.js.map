{"version":3,"names":["_QueryBase","require","FilterStageImpl","QueryBase","constructor","origin","collectionName","filterBuilder","copy","params","invalidArguments","toProto","filter","build","exports"],"sources":["../../../../src/api/stages/FilterStage.ts"],"sourcesContent":["import { QueryBase } from '../QueryBase'\nimport { PlatformizedFilterBuilder, WithFilter } from '../../filter'\nimport * as apiTypes from '../../types/data-item-types'\nimport { PipelineStage } from './stages'\n\ntype Comparable = string | number | Date\n\n/**\n * @builder\n * Filter stage for aggregate pipeline operations. This interface provides filtering capabilities\n * specifically designed for use within aggregate pipelines, typically used with `stages.filter()`\n * in pipeline arrays to refine data based on specified conditions.\n */\nexport interface FilterStage extends PipelineStage, WithFilter<FilterStage> {\n  /**\n   * @internal\n   */\n  readonly filterTree: Record<string, any>\n\n  /**\n   * @internal\n   */\n  readonly invalidArguments: string[]\n\n  /**\n   * Filters pipeline data to match items whose specified field value equals the specified value.\n   *\n   * The `eq()` method refines this aggregate pipeline filter to only\n   * match items where the value of the specified field equals the specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type does not match the same number stored as a Number type.\n   *\n   * Matching strings with `eq()` is case sensitive, so `\"text\"` is not equal to `\"Text\"`.\n   *\n   * If `field` points to a collection field of type array, `eq()` includes the item as long as at least one array element matches the specified `value`.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to compare with.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  eq(field: string, value: any): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value does not equal the specified value.\n   *\n   * The `ne()` method refines this aggregate pipeline filter to only\n   * match items where the value of the specified field does not equal the specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type is considered not equal to the same number stored as a Number type.\n   *\n   * Matching strings with `ne()` is case sensitive, so `\"text\"` is not equal to `\"Text\"`.\n   *\n   * If the value of `field` is an array, `ne()` includes items\n   * in which none of the elements of the array match the specified `value`.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to match.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  ne(field: string, value: any): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value is greater than or equal to the specified\n   * value.\n   *\n   * The `ge()` method refines this aggregate pipeline filter to only\n   * match items where the value of the specified field is greater than or\n   * equal to the specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type does not match the same number stored as a Number type.\n   *\n   * If a field contains a number as a String, that value is compared\n   * alphabetically and not numerically. Items that do not have a value for the\n   * specified field are ranked lowest.\n   *\n   * The following field types can be compared:\n   * - Number: Compares numerically.\n   * - Date: Compares JavaScript Date objects.\n   * - String: Compares lexicographically,\n   *   so `\"abc\"` is greater than or equal to `\"ABC\"` (because of the greater than),\n   *   but `\"ABC\"` is not greater than or equal to `\"abc\"`.\n   * - Reference: Compares by the ID of the referenced item as a String.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to match.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  ge(field: string, value: string | number | Date): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value is greater than the specified value.\n   *\n   * The `gt()` method refines this aggregate pipeline filter to only match\n   * items where the value of the specified field is greater than the specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type does not match the same number stored as a Number type.\n   *\n   * If a field contains a number as a String, that value is compared\n   * alphabetically and not numerically. Items that do not have a value for the\n   * specified field are ranked lowest.\n   *\n   * The following field types can be compared:\n   * - Number: Compares numerically.\n   * - Date: Compares JavaScript Date objects.\n   * - String: Compares lexicographically, so `\"text\"` is greater than `\"Text\"`.\n   * - Reference: Compares by the ID of the referenced item as a String.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to match.\n   * @requiredField value\n   * @returns An object with the filter definition, based on the supplied parameters.\n   */\n  gt(field: string, value: string | number | Date): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value is less than or equal to the specified\n   * value.\n   *\n   * The `le()` method refines this aggregate pipeline filter to only match\n   * items where the value of the specified field is less than or equal to the\n   * specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type does not match the same number stored as a Number type.\n   *\n   * If a field contains a number as a String, that value is compared\n   * alphabetically and not numerically. Items that do not have a value for the\n   * specified field are ranked lowest.\n   *\n   * The following field types can be compared:\n   * - Number: Compares numerically.\n   * - Date: Compares JavaScript Date objects.\n   * - String: Compares lexicographically,\n   *   so `\"ABC\"` is less than or equal to `\"abc\"` (because of the less than),\n   *   but `\"abc\"` is not less than or equal to `\"ABC\"`.\n   * - Reference: Compares by the ID of the referenced item as a String.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to match.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  le(field: string, value: string | number | Date): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value is less than the specified value.\n   *\n   * The `lt()` method refines this aggregate pipeline filter to only match\n   * items where the value of the specified field is less than the specified `value`.\n   *\n   * It only matches values of the same type. For example, a number value stored\n   * as a String type does not match the same number stored as a Number type.\n   *\n   * If a field contains a number as a String, that value is compared\n   * alphabetically and not numerically. Items that do not have a value for the\n   * specified field are ranked lowest.\n   *\n   * The following field types can be compared:\n   * - Number: Compares numerically.\n   * - Date: Compares JavaScript Date objects.\n   * - String: Compares lexicographically, so `\"Text\"` is less than `\"text\"`.\n   * - Reference: Compares by the ID of the referenced item as a String.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param value - Value to match.\n   * @requiredField value\n   * @returns An object with the filter definition, based on the supplied parameters.\n   */\n  lt(field: string, value: string | number | Date): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field has any value.\n   *\n   * The `isNotEmpty()` method refines this aggregate pipeline filter to only match items where the\n   * value of the specified field is not `null` or `undefined`.\n   *\n   * If the field contains any value at all for a given item, including the\n   * empty string or an invalid value, that item will match the filter.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field in which to check for a value.\n   * @requiredField field\n   * @returns Refined filter.\n   */\n  isNotEmpty(field: string): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field does not exist or does not have any value.\n   *\n   * The `isEmpty()` method refines this aggregate pipeline filter to only match items where the\n   * value of the specified field is `null` or `undefined` or the field does\n   * not exist.\n   *\n   * If the field contains any value at all for a given item, including the\n   * empty string or an invalid value, that item will match the filter.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field in which to check for a value.\n   * @requiredField field\n   * @returns An object representing the refined filter.\n   */\n  isEmpty(field: string): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value starts with a specified string.\n   *\n   * The `startsWith()` method refines this aggregate pipeline filter to\n   * only match items where the value of the specified field starts with the\n   * defined `string`. Matching with `startsWith()` is not case sensitive, so `\"TEXT\"` starts\n   * with `\"tex\"`.\n   *\n   * You can only use `startsWith()` with a field whose value is a String or Reference.\n   * When using a Reference, `startsWith()` matches by the ID of the referenced item as Strings.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with the `value` parameter.\n   * @requiredField field\n   * @param value - Value to look for at the beginning of the specified field value.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  startsWith(field: string, value: string): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value ends with a specified string.\n   *\n   * The `endsWith()` method refines this aggregate pipeline filter to only\n   * match items where the value of the specified field ends with the specified\n   * `string`. Matching with `endsWith()` is not case sensitive, so `\"TEXT\"` ends\n   * with `\"ext\"`.\n   *\n   * You can only use `endsWith()` with a field whose value is a String or Reference.\n   * When using a Reference, `endsWith()` matches by the ID of the referenced item as Strings.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with the string.\n   * @requiredField field\n   * @param value - Value to look for at the end of the specified field value.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  endsWith(field: string, value: string): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value contains the specified value.\n   *\n   * The `contains()` method refines the aggregate pipeline filter to only match items for which the value of the specified field contains the specified value. `contains()` is not case-sensitive, so the value `sunday` is considered to contain the value `Sun`.\n   *\n   * You can use `contains()` with a field whose type is a string or a reference. However, for fields whose type is reference, `contains()` matches by the ID of the referenced item as a string. Instead, use the [`eq()`](https://dev.wix.com/docs/sdk/backend-modules/data/wix-data-items-sdk-1-0-0/wix-data-filter/eq) method.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with the provided value.\n   * @requiredField field\n   * @param value - Value to locate in the specified field value.\n   * @requiredField value\n   * @returns Refined filter.\n   */\n  contains(field: string, value: string): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value equals any of the specified `values`\n   * parameters.\n   *\n   * The `hasSome()` method refines this aggregate pipeline filter to\n   * only match items where the value of the specified field equals any of\n   * the specified values.\n   *\n   * Matching strings with `hasSome()` is case sensitive, so `\"text\"` is not equal to `\"Text\"`.\n   *\n   * If the value of the specified field is an array, `hasSome()` will match\n   * if any of the elements of that array match any of the specified values.\n   *\n   * If the specified field contains multiple references, pass item IDs in the\n   * `value` field. In such a case, `hasSome()` will match if any of the\n   * multiple references match any of the specified ID values.\n   *\n   * You can specify a list of values to match by providing an array of\n   * String, Number, or Date types as the `value` parameters.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `value`.\n   * @requiredField field\n   * @param values - Values to match.\n   * @requiredField values\n   * @returns An object representing the refined filter.\n   */\n  hasSome(field: string, ...values: Comparable[]): FilterStage\n\n  /**\n   * Overload for `hasSome()`\n   * @public\n   * @documentationMaturity preview\n   */\n  hasSome(field: string, values: Comparable[]): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field values equals all of the specified `value`\n   * parameters.\n   *\n   * The `hasAll()` method refines this aggregate pipeline filter to\n   * only match items where the value of the specified field equals all of\n   * the specified values.\n   *\n   * Matching strings with `hasAll()` is case sensitive, so `\"text\"` is not equal to `\"Text\"`.\n   *\n   * If the value of the specified field is an array, `hasAll()` will match\n   * if there is a match in the elements of that array for all of the specified\n   * values.\n   *\n   * You can specify a list of values to match by providing an array of\n   * String, Number, or Date types as the `value` parameters.\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field whose value is compared with `values`.\n   * @requiredField field\n   * @param values - Values to match.\n   * @requiredField values\n   * @returns An object representing the refined filter.\n   */\n  hasAll(field: string, ...values: Comparable[]): FilterStage\n\n  /**\n   * Overload for `hasAll()`\n   * @public\n   * @documentationMaturity preview\n   */\n  hasAll(field: string, values: Comparable[]): FilterStage\n\n  /**\n   * Adds an `or` condition to the aggregate pipeline filter.\n   *\n   * The `or()` method adds an inclusive `or` condition to this pipeline filter. A filter\n   * with an `or` returns all the items that match the filter as defined up to\n   * the `or` method, the items that match the filter passed to the `or`\n   * method, and the items that match both.\n   *\n   * The `or()` method is designed to work with 2 or more queries or filters.\n   * If you use it on its own, it will return all the items in a collection.\n   * @public\n   * @documentationMaturity preview\n   * @param filter - Filter to add to the initial filter as an `or` condition.\n   * @requiredField filter\n   * @returns Object representing the refined filter.\n   */\n  or(filter: FilterStage): FilterStage\n\n  /**\n   * Adds an `and` condition to the aggregate pipeline filter.\n   *\n   * A pipeline filter with an `and` condition returns all items that meet the conditions defined on both sides of the condition.\n   *\n   * Use the `and()` method when performing compound queries. For example, the final filter in this set of\n   * queries returns results where status is either pending or rejected **and** age is either less than 25 or greater\n   * than 65.\n   *\n   * ```js\n   * let statusFilter = stages.filter()\n   *   .eq(\"status\", \"pending\")\n   *   .or(stages.filter().eq(\"status\", \"rejected\"));\n   *\n   * let ageFilter = stages.filter()\n   *   .lt(\"age\", 25)\n   *   .or(stages.filter().gt(\"age\", 65));\n   *\n   * let statusAndAgeFilter = statusFilter.and(ageFilter);\n   * ```\n   *\n   * > **Notes**:\n   * > - The `and()` method is designed to work with 2 or more queries or filters. If used with a single query or filter, it returns all items in a collection.\n   * > - When chaining multiple `FilterStage` methods to a filter, an `and` condition is implied. In such cases, you do not need to call the `and()` method explicitly. For example, this filter returns results where an item `status` is `active` and `age` is greater than 25:\n   *\n   * ```js\n   * stages.filter().eq(\"status\", \"active\").gt(\"age\", 25);\n   * ```\n   *\n   * @public\n   * @documentationMaturity preview\n   * @param filter - `FilterStage` used with an `and` condition.\n   * @requiredField filter\n   * @returns The compound filter.\n   */\n  and(filter: FilterStage): FilterStage\n\n  /**\n   * Adds a `not` condition to the aggregate pipeline filter.\n   *\n   * The `not()` method adds a `not` condition to this pipeline filter. A filter with a `not`\n   * returns all the items that match the filter as defined up to the `not`\n   * method, but don't match the filter passed to the `not` method.\n   *\n   * If the filter only contains a `not()` method, it returns all the items\n   * that don't match the filter defined by the `not` method.\n   *\n   * @public\n   * @documentationMaturity preview\n   * @param filter - Filter to add to the initial filter as a `not` condition.\n   * @requiredField filter\n   * @returns Object representing the refined filter.\n   */\n  not(filter: FilterStage): FilterStage\n\n  /**\n   * Filters pipeline data to match items whose specified field value is within the defined range.\n   *\n   * The `between()` method refines this aggregate pipeline filter to match items for which the value of the specified field is greater than or equal to `rangeStart` and less than `rangeEnd`. The method only matches values of [the same type](https://support.wix.com/en/article/cms-formerly-content-manager-about-your-collection-fields#field-type).\n   *\n   * The following types can be compared:\n   * - Number: Compared numerically.\n   * - Date: Compared as JavaScript Date objects.\n   * - String: Compared lexicographically:\n   *   - `\"A\"` and `\"M\"` are considered between `\"A\"` and `\"Z\"`, but `\"a\"`, `\"m\"`, `\"z\"` and `\"Z\"` are not.\n   *   - `\"A\"`, `\"M\"`, `\"Z\"`, and `\"a\"` are considered between `\"A\"` and `\"z\"`, but `\"z\"` is not.\n   *\n   * > **Note**: Items that do not have a value for the specified field are considered as the lowest comparable value and are ranked last.\n   *\n   * @public\n   * @documentationMaturity preview\n   * @param field - Field to compare with `rangeStart` and `rangeEnd`.\n   * @requiredField field\n   * @param rangeStart - Starting value of the range to match.\n   * @requiredField rangeStart\n   * @param rangeEnd - Ending value of the range to match.\n   * @requiredField rangeEnd\n   * @returns Refined filter.\n   */\n  between(\n    field: string,\n    rangeStart: string | number | Date,\n    rangeEnd: string | number | Date\n  ): FilterStage\n}\n\nexport class FilterStageImpl\n  extends QueryBase<FilterStageImpl>\n  implements FilterStage\n{\n  constructor(origin?: {\n    collectionName?: string\n    filterBuilder?: PlatformizedFilterBuilder\n  }) {\n    super({\n      collectionName: origin?.collectionName || '',\n      filterBuilder: origin?.filterBuilder,\n    })\n  }\n\n  protected copy(params: any): FilterStageImpl {\n    return new FilterStageImpl({\n      collectionName: this.collectionName,\n      filterBuilder: params.filterBuilder || this.filterBuilder,\n    })\n  }\n\n  get invalidArguments(): string[] {\n    return []\n  }\n\n  toProto(): apiTypes.Stage {\n    return { filter: this.filterBuilder.build() }\n  }\n}\n"],"mappings":";;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AAOA;AACA;AACA;AACA;AACA;AACA;;AAubO,MAAMC,eAAe,SAClBC,oBAAS,CAEnB;EACEC,WAAWA,CAACC,MAGX,EAAE;IACD,KAAK,CAAC;MACJC,cAAc,EAAE,CAAAD,MAAM,oBAANA,MAAM,CAAEC,cAAc,KAAI,EAAE;MAC5CC,aAAa,EAAEF,MAAM,oBAANA,MAAM,CAAEE;IACzB,CAAC,CAAC;EACJ;EAEUC,IAAIA,CAACC,MAAW,EAAmB;IAC3C,OAAO,IAAIP,eAAe,CAAC;MACzBI,cAAc,EAAE,IAAI,CAACA,cAAc;MACnCC,aAAa,EAAEE,MAAM,CAACF,aAAa,IAAI,IAAI,CAACA;IAC9C,CAAC,CAAC;EACJ;EAEA,IAAIG,gBAAgBA,CAAA,EAAa;IAC/B,OAAO,EAAE;EACX;EAEAC,OAAOA,CAAA,EAAmB;IACxB,OAAO;MAAEC,MAAM,EAAE,IAAI,CAACL,aAAa,CAACM,KAAK,CAAC;IAAE,CAAC;EAC/C;AACF;AAACC,OAAA,CAAAZ,eAAA,GAAAA,eAAA","ignoreList":[]}