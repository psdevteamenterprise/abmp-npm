import { WixDataResultImpl } from './WixDataResultImpl';
import { PipelineValidator } from '../PipelineValidator';
export class WixDataAggregatePipelineImpl {
    constructor(collectionName, pipeline, client, limitNumber, skipNumber, invalidArguments) {
        this.collectionName = collectionName;
        this.pipeline = pipeline;
        this.client = client;
        this.limitNumber = limitNumber;
        this.skipNumber = skipNumber;
        this.ownInvalidArguments = invalidArguments ?? [];
    }
    get invalidArguments() {
        return this.ownInvalidArguments;
    }
    async run(options) {
        if (this.invalidArguments.length > 0) {
            throw new Error(this.invalidArguments.join(', '));
        }
        const stages = this.pipeline.map((stage) => stage.toProto());
        const response = await this.client.aggregatePipelineDataItems({
            dataCollectionId: this.collectionName,
            stages,
            ...options,
            paging: { offset: this.skipNumber, limit: this.limitNumber },
        });
        const fetch = async (cursorOrOffset, returnTotalCount) => {
            const request = {
                dataCollectionId: this.collectionName,
                stages,
                ...options,
            };
            if (typeof cursorOrOffset === 'string') {
                request.cursorPaging = {
                    limit: this.limitNumber,
                    cursor: cursorOrOffset,
                };
                // Stages must not be sent if using cursor paging, as they'll be reused from original request
                request.stages = undefined;
            }
            else {
                request.paging = { limit: this.limitNumber, offset: cursorOrOffset };
            }
            if (returnTotalCount) {
                request.returnTotalCount = true;
            }
            const { results, pagingMetadata } = await this.client.aggregatePipelineDataItems(request);
            return [results, pagingMetadata];
        };
        return new WixDataResultImpl(response.results || [], response.pagingMetadata || { count: 0, offset: 0 }, fetch, {
            collectionName: this.collectionName,
            skipNumber: response.pagingMetadata?.offset || 0,
            limitNumber: response.results?.length,
        });
    }
    limit(limitNumber) {
        const [invalidArguments] = this.pipelineValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .validateAndAggregate();
        return this.copy({ limitNumber, invalidArguments });
    }
    skip(skipNumber) {
        const [invalidArguments] = this.pipelineValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .validateAndAggregate();
        return this.copy({ skipNumber, invalidArguments });
    }
    pipelineValidator(operatorName) {
        return new PipelineValidator(operatorName, this.ownInvalidArguments);
    }
    copy(params) {
        return new WixDataAggregatePipelineImpl(this.collectionName, this.pipeline, this.client, params.limitNumber ?? this.limitNumber, params.skipNumber ?? this.skipNumber, params.invalidArguments ?? this.ownInvalidArguments);
    }
}
//# sourceMappingURL=WixDataAggregatePipelineImpl.js.map