import { NumericExpressionImpl } from '../expressions/Expression';
export class GroupStageImpl {
    constructor() {
        this.ids = [];
        this.accumulators = [];
    }
    by(expression, key) {
        this.ids.push({ expression, key });
        return this;
    }
    sum(expression, resultFieldName) {
        return this.addAccumulator(expression, 'sum', resultFieldName);
    }
    avg(expression, resultFieldName) {
        return this.addAccumulator(expression, 'avg', resultFieldName);
    }
    min(expression, resultFieldName) {
        return this.addAccumulator(expression, 'min', resultFieldName);
    }
    max(expression, resultFieldName) {
        return this.addAccumulator(expression, 'max', resultFieldName);
    }
    count(resultFieldName) {
        return this.addAccumulator(new NumericExpressionImpl(1), 'sum', resultFieldName);
    }
    first(expression, resultFieldName) {
        return this.addAccumulator(expression, 'first', resultFieldName);
    }
    last(expression, resultFieldName) {
        return this.addAccumulator(expression, 'last', resultFieldName);
    }
    push(expression, resultFieldName) {
        return this.addAccumulator(expression, 'push', resultFieldName);
    }
    addAccumulator(expression, type, resultFieldName) {
        this.accumulators.push({ type, expression, resultFieldName });
        return this;
    }
    toProto() {
        return {
            group: {
                groupIds: this.ids.map((id) => ({
                    expression: id.expression.toProto(),
                    key: id.key,
                })),
                accumulators: this.accumulators.map((accumulator) => ({
                    [accumulator.type]: {
                        expression: accumulator.expression.toProto(),
                    },
                    resultFieldName: accumulator.resultFieldName,
                })),
            },
        };
    }
}
//# sourceMappingURL=GroupStage.js.map